
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Multi-Qubit Systems &#8212; Quantum Computing using Python</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=ab0149b2" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapters/02_quantum_computing/02_04_multi_qb_sys';</script>
    <link rel="canonical" href="https://learn-quantum.github.io/lqc-textbook/chapters/02_quantum_computing/02_04_multi_qb_sys.html" />
    <link rel="icon" href="../../_static/nabla.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Quantum Building Blocks" href="02_05_quantum_blocks.html" />
    <link rel="prev" title="Single-Qubit Systems" href="02_03_single_qb_sys.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.svg" class="logo__image only-light" alt="Quantum Computing using Python - Home"/>
    <script>document.write(`<img src="../../_static/logo.svg" class="logo__image only-dark" alt="Quantum Computing using Python - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../00_getting_started/00_00_welcome.html">About the Textbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../00_getting_started/00_01_setting_env.html">Setting Up your Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../00_getting_started/00_02_qiskit_config.html">Configuring Qiskit</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Classical Computing</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../01_classical_computing/01_01_bits_and_circuits.html">Bits and Digital Circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_classical_computing/01_02_reversible_computing.html">Reversible Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_classical_computing/01_03_bits_to_vectors.html">Linear Algebra for Reversible Circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_classical_computing/01_04_probabilistic_circuits.html">Probabilistic Computing</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Quantum Computing</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="02_01_bits_to_qubits.html">Qubits and Quantum Circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_02_entanglement.html">Quantum Entanglement</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_03_single_qb_sys.html">Single-Qubit Systems</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Multi-Qubit Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_05_quantum_blocks.html">Quantum Building Blocks</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Quantum Protocols</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../03_quantum_protocols/03_01_quantum_money.html">Quantum Money</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_quantum_protocols/03_02_bell_chsh.html">Bell Inequalities (CHSH)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_quantum_protocols/03_03_bb84_e91.html">The BB84 &amp; E91 Protocols</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_quantum_protocols/03_04_teleportation.html">Quantum Teleportation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_quantum_protocols/03_05_superdense_coding.html">Superdense Coding</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Quantum Algorithms</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../04_quantum_algorithms/04_01_deutsch-jozsa.html">Deutsch-Jozsa Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_quantum_algorithms/04_02_bernstein-vazirani.html">Bernstein–Vazirani Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_quantum_algorithms/04_03_simons.html">Simon’s Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_quantum_algorithms/04_04_grover.html">Grover’s Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_quantum_algorithms/04_05_amp_amp.html">Amplitude Amplification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_quantum_algorithms/04_06_qft.html">Quantum Fourier Transform</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/learn-quantum/lqc-textbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/learn-quantum/lqc-textbook/issues/new?title=Issue%20on%20page%20%2Fchapters/02_quantum_computing/02_04_multi_qb_sys.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/chapters/02_quantum_computing/02_04_multi_qb_sys.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Multi-Qubit Systems</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-states">1. Multi-Qubit States</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-gates">2. Multi-Qubit Gates</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#one-qubit-gates-on-multiple-qubits">2.1 One-Qubit Gates (on Multiple Qubits)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">2.2 Multi-Qubit Gates</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#controlled-gates">2.2.1 Controlled Gates</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-swap-gate">2.2.2 The SWAP Gate</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-copy-gate-no-cloning-theorem">2.3 The Copy Gate (No-Cloning Theorem)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#universal-gate-sets">2.4 Universal Gate Sets</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-measurements">3. Multi-Qubit Measurements</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#full-state-measurement">3.1 Full State Measurement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-state-measurement">3.2 Partial State Measurement</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="multi-qubit-systems">
<h1>Multi-Qubit Systems<a class="headerlink" href="#multi-qubit-systems" title="Link to this heading">#</a></h1>
<hr></hr><p>Now that we have the complete definition for a <a class="reference internal" href="#(https://learnquantum.io/chapters/02_quantum_computing/02_03_single_qb_sys.html#kets-bras-products-and-bases)"><span class="xref myst">single qubit</span></a>, in this chapter we will generalize this idea to statevectors representing several qubits. We will also discuss multi-qubit quantum gates, introduce the <a class="reference external" href="https://en.wikipedia.org/wiki/No-cloning_theorem">no-cloning theorem</a>, briefly cover the concept of a <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates">universal gate-set</a>, and expand on the concept of measurement for multi-qubit systems.</p>
<section id="multi-qubit-states">
<h2>1. Multi-Qubit States<a class="headerlink" href="#multi-qubit-states" title="Link to this heading">#</a></h2>
<p>In the previous chapter, we went over the details of why a qubit is represented by a vector of the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}|q\rangle = \begin{bmatrix} \alpha_0 \\ \alpha_1 \end{bmatrix}, \end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_0\)</span> and <span class="math notranslate nohighlight">\(\alpha_1\)</span> are complex numbers known as probability amplitudes, and whose modulus square represents the probability of measuring each of their corresponding state, and therefore must add up to <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="math notranslate nohighlight">
\[|\alpha_0|^2 + |\alpha_1|^2 = 1 .\]</div>
<p>We also briefly discussed that a state of this form corresponds to a linear combination of the computational basis states <span class="math notranslate nohighlight">\(\{|0\rangle, |1\rangle\} \)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
|q\rangle &amp;= \begin{bmatrix} \alpha_0 \\ \alpha_1 \end{bmatrix} 
\\
\\
|q\rangle &amp;= \alpha_0 \begin{bmatrix} 1 \\ 0 \end{bmatrix} + \alpha_1 \begin{bmatrix} 0 \\ 1 \end{bmatrix}
\\
\\
|q\rangle &amp;= \alpha_0 |0\rangle + \alpha_1 |1\rangle.
\end{aligned}
\end{split}\]</div>
<p>We can then generalize this expression for <span class="math notranslate nohighlight">\(n\)</span> qubits by taking a linear combination of all possible basis states for the complete system: <span class="math notranslate nohighlight">\(\{|0\rangle, |1\rangle\}^{\otimes n}\)</span>. Here, the superscript <span class="math notranslate nohighlight">\(^{\otimes n}\)</span> denotes that we are taking the tensor product <span class="math notranslate nohighlight">\(n\)</span> times for all possible combinations of <span class="math notranslate nohighlight">\(|0\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\{|0\rangle, |1\rangle\}^{\otimes n} = \{|\underbrace{0\dots 00}_{n}\rangle, |\underbrace{0\dots 01}_{n}\rangle, \dots, |\underbrace{1\dots 11}_{n}\rangle \}\]</div>
<p>For example, for <span class="math notranslate nohighlight">\(n = 3\)</span>:</p>
<div class="math notranslate nohighlight">
\[\{|0\rangle, |1\rangle\}^{\otimes3} = \{|000\rangle, |001\rangle, |010\rangle, |011\rangle, |100\rangle, |101\rangle, |110\rangle, |111\rangle \} .\]</div>
<p>It can be seen that for <span class="math notranslate nohighlight">\(n\)</span> qubits, there are a total of <span class="math notranslate nohighlight">\(N = 2^n\)</span> basis states. So, the general representation of a quantum state for an <span class="math notranslate nohighlight">\(n\)</span>-qubit system is given by:</p>
<div class="math notranslate nohighlight">
\[ |q\rangle = \alpha_{0} |0\dots 00\rangle + \alpha_{1}|0\dots 01\rangle + \dots + \alpha_{N-1}|1 \dots 11\rangle ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha_j \in \mathbb{C}\)</span> are the probability amplitudes associated with each basis state. And since their square modulus <span class="math notranslate nohighlight">\(|\alpha_j|^2\)</span> represent probabilities, they must also meet the condition of adding up to <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \sum_{j=0}^{N-1} |\alpha_j|^2 = 1 .\]</div>
<p>A more compact way to write the expresion for a multi-qubit vector is:</p>
<div class="math notranslate nohighlight">
\[ |q\rangle = \sum_{j=0}^{N-1} \alpha_{j} |j\rangle. \]</div>
<p>However, we do have to point out that this is a slight abuse of notation because, here <span class="math notranslate nohighlight">\(j\)</span> represents an integer between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{N-1}\)</span>, so we need to clarify what we mean by <span class="math notranslate nohighlight">\(|j\rangle\)</span> is the state with binary label that corresponds to that integer value. For example, for <span class="math notranslate nohighlight">\(j = 5\)</span>:</p>
<div class="math notranslate nohighlight">
\[ |5\rangle \sim |101\rangle = |1\rangle \otimes |0\rangle \otimes |1\rangle .\]</div>
<p>It is also important to remember that, just as for the single-qubit case, the basis states <span class="math notranslate nohighlight">\(\{|0\rangle, |1\rangle\}^{\otimes n}\)</span> form an orthonormal basis because they meet the condition of being orthogonal to each other and normalized. A succinct form to express this is as:</p>
<div class="math notranslate nohighlight">
\[ \langle i | j \rangle = \delta_{ij}\]</div>
<p>where <span class="math notranslate nohighlight">\(i, j\)</span> denote any of the possible basis states between <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2^{N-1}\)</span>, and <span class="math notranslate nohighlight">\(\delta_{ij}\)</span> is known as the Kronecker-delta function, given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split} \delta_{ij} = 
\begin{cases} 
1 \text{, for } i = j 
\\
\\
0 \text{, for } i \neq j
\end{cases} 
\end{split}\]</div>
<p>We can also represent a general multi-qubit statevector using column-vector notation as:</p>
<div class="math notranslate nohighlight">
\[\begin{split} |q\rangle = \begin{bmatrix} \alpha_0 \\ \alpha_1 \\ \vdots \\ \alpha_{N-1} \end{bmatrix}, \text{ such that:} \; \alpha_j \in \mathbb{C}, \; \text{and} \; \sum_{j=0}^{N-1}|\alpha_j|^2 = 1 . \end{split}\]</div>
<p>And just like we did for the one-qubit case, we say that all statevectors of this kind belong to a <a class="reference external" href="https://en.wikipedia.org/wiki/Hilbert_space">Hilbert space</a> but now of size <span class="math notranslate nohighlight">\(N = 2^n\)</span>, which is often expressed as <span class="math notranslate nohighlight">\(\mathcal{H}_2^{\otimes n}\)</span>. The subscript <span class="math notranslate nohighlight">\(2\)</span> is to denote this is for a <span class="math notranslate nohighlight">\(2\)</span>-level (qubit) system, and the superscript <span class="math notranslate nohighlight">\(^{\otimes n}\)</span> is to express that we have <span class="math notranslate nohighlight">\(n\)</span> of these systems.</p>
<p>Let’s now look at a few examples of multi-qubit statevectors in Qiskit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qiskit.quantum_info</span><span class="w"> </span><span class="kn">import</span> <span class="n">Statevector</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create equal superposition state for 3 qubits (separable)</span>
<span class="n">ψ_a</span> <span class="o">=</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;+++&#39;</span><span class="p">)</span>

<span class="c1"># Display statevector in ket notation</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ket notation:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">ψ_a</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">))</span>

<span class="c1"># Display statevector in vector notation</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Vector notation:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">ψ_a</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;vector&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Ket notation:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\frac{\sqrt{2}}{4} |000\rangle+\frac{\sqrt{2}}{4} |001\rangle+\frac{\sqrt{2}}{4} |010\rangle+\frac{\sqrt{2}}{4} |011\rangle+\frac{\sqrt{2}}{4} |100\rangle+\frac{\sqrt{2}}{4} |101\rangle+\frac{\sqrt{2}}{4} |110\rangle+\frac{\sqrt{2}}{4} |111\rangle\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Vector notation:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4} &amp; \frac{\sqrt{2}}{4}  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create 3-qubit entangled state</span>
<span class="n">ψ_b</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;000&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">Statevector</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;111&#39;</span><span class="p">)</span>

<span class="c1"># Display statevector in ket notation</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ket notation:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">ψ_b</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">))</span>

<span class="c1"># Display statevector in vector notation</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Vector notation:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">ψ_b</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;vector&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Ket notation:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\frac{\sqrt{2}}{2} |000\rangle+\frac{\sqrt{2}}{2} |111\rangle\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Vector notation:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \frac{\sqrt{2}}{2}  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>As can be seen from these examples, both separable and entangled states consists of linear combinations of basis states. It is the value that each probability amplitude takes that ultimately determines if a state is separable of entangled. If the state of an <span class="math notranslate nohighlight">\(n\)</span>-qubit system can be ultimately factorized into a <strong>single</strong> term of tensor products for <span class="math notranslate nohighlight">\(n\)</span> separate states, we say the state is separable:</p>
<div class="math notranslate nohighlight">
\[ |q\rangle = |q_{n-1}\rangle \otimes \dots \otimes |q_1\rangle \otimes |q_0\rangle .\]</div>
<p>On the other hand, if a state can only be expressed as a sum of tensor products (i.e., cannot be factorized like shown above), we say the state is entangled.</p>
<p>Figuring out if a state can be factorized by inspection gets increasingly difficult when the number of qubits increases. Therefore, there are procedures that allow one to, not only discern if a state is entangled, but also to quantify its level of entanglement. However, the subject of measures of entanglement is quite diverse and a bit advanced, so we will cover some of these details in a later chapter on quantum information theory.</p>
</section>
<section id="multi-qubit-gates">
<h2>2. Multi-Qubit Gates<a class="headerlink" href="#multi-qubit-gates" title="Link to this heading">#</a></h2>
<p>Just as we pointed out for the <a class="reference external" href="https://learnquantum.io/chapters/02_quantum_computing/02_03_single_qb_sys.html#generalizing-quantum-gates">single-qubit case</a>, multi-qubit gates and circuits can be expressed in the form of a <a class="reference external" href="https://en.wikipedia.org/wiki/Unitary_matrix">unitary matrix</a> <span class="math notranslate nohighlight">\(U\)</span>, such that:</p>
<div class="math notranslate nohighlight">
\[ UU^\dagger = U^\dagger U = I .\]</div>
<p>For a system of <span class="math notranslate nohighlight">\(n\)</span> qubits, the matrices will be of size <span class="math notranslate nohighlight">\(N \times N\)</span>, with <span class="math notranslate nohighlight">\(N = 2^n\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split} U = \begin{bmatrix}u_{0,0} &amp; u_{0,1} &amp; \dots &amp; u_{0,(N-1)} \\
                      u_{1,0} &amp; u_{1,1} &amp; \dots &amp; u_{1,(N-1)} \\
                      \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
                      u_{(N-1),0} &amp; u_{(N-1),1} &amp; \dots &amp; u_{(N-1),(N-1)}
\end{bmatrix} \end{split}\]</div>
<p>For the specific case of multi-qubit systems composed solely of single-qubit gates acting on each individual qubit, it is easy to compute the total unitary matrix that acts on the whole system by taking the Kronecker product between the individual one-qubit operations. However, these separable operations cannot be used to generate entangled states, and therefore correspond to only limited subset of all possible unitaries that can act on a given Hilbert space.</p>
<section id="one-qubit-gates-on-multiple-qubits">
<h3>2.1 One-Qubit Gates (on Multiple Qubits)<a class="headerlink" href="#one-qubit-gates-on-multiple-qubits" title="Link to this heading">#</a></h3>
<p>Similar to what we saw for classical reversible circuits, gates acting on individual qubits that are part of a larger multi-qubit system can be combined into a single unitary by taking the Kronecker product between them:</p>
<div class="math notranslate nohighlight">
\[ U = \bigotimes_{j=0}^{N-1} U_j .\]</div>
<p>Let’s look at an example in Qiskit where we apply gates <span class="math notranslate nohighlight">\(X, H, Z\)</span> on qubits <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span>, respectively:</p>
<div class="math notranslate nohighlight">
\[ U = Z \otimes H \otimes X .\]</div>
<p>We will first create the individual matrices for each gate and apply the Kronecker (tensor) product between them, and compare this with the total unitary (operator) for the whole circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">qiskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">QuantumCircuit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qiskit.quantum_info</span><span class="w"> </span><span class="kn">import</span> <span class="n">Operator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute total Unitary (operator) by tensoring gates</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>

<span class="n">ZHX</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="n">ZHX</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;U =&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
U =
\begin{bmatrix}
0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2}  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2}  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/cc0c1c1098875d78cd0ac06f65b3570665e66b4eaca378f43396dcf010340521.png" src="../../_images/cc0c1c1098875d78cd0ac06f65b3570665e66b4eaca378f43396dcf010340521.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Operator from total circuit matches that of tensor product of individual matrices</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;U =&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
U =
\begin{bmatrix}
0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2}  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2}  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; - \frac{\sqrt{2}}{2} &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Unitaries composed of tensor products of single-qubit unitaries are only a small fraction of all possible operations that can act on a multi-qubit state. For example the matrices for the <span class="math notranslate nohighlight">\(CX\)</span> or the Toffoli (<span class="math notranslate nohighlight">\(CCX\)</span>) gates, which we covered before, cannot be expressed in terms of tensor products of other unitaries. Since there is an infinite number of unitaries that can be implemented for any given qubit system, we will focus our attention on a few popular/common gates. However, any multi-qubit unitary can actually be decomposed into combinations of other gates that are part of what is known as a <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates">universal gate-set</a>. In other words, we can approximate with arbitrary precision any unitary of size <span class="math notranslate nohighlight">\(N \times N\)</span> by combining operations from small set of single-qubit and two-qubit gates.</p>
</section>
<section id="id1">
<h3>2.2 Multi-Qubit Gates<a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<p>Multi-qubit gates that cannot be expressed as a single tensor product of individual qubit gates (like the ones described in the previous section) are sometimes referred as <strong>entangling gates</strong>. This is because, as the name implies, they can be used to construct circuits that allow us to generate entangled states. Probably the most common type of entangling gates are controlled gates, which are a generalization of the of the controlled <span class="math notranslate nohighlight">\(X\)</span> gates we’ve discussed before.</p>
<section id="controlled-gates">
<h4>2.2.1 Controlled Gates<a class="headerlink" href="#controlled-gates" title="Link to this heading">#</a></h4>
<p>Just like the <span class="math notranslate nohighlight">\(CX\)</span> gate is a controlled version of an <span class="math notranslate nohighlight">\(X\)</span> gate, we can expand any other gate with a unitary <span class="math notranslate nohighlight">\(U\)</span> into a controlled version of it. The idea is that the gate of interest gets applied to a <strong>target</strong> set of qubits if a certain condition is met in a set of <strong>control</strong> qubits.</p>
<p>For example, in the case of a <span class="math notranslate nohighlight">\(CX\)</span> gate:</p>
<ol class="arabic simple">
<li><p>An <span class="math notranslate nohighlight">\(X\)</span> gate is applied to the target qubit if the control qubit is in state <span class="math notranslate nohighlight">\(|1\rangle\)</span>.</p></li>
<li><p>An <span class="math notranslate nohighlight">\(I\)</span> gate is applied to the target qubit if the control qubit is in state <span class="math notranslate nohighlight">\(|0\rangle\)</span>.</p></li>
</ol>
<p>And the way we constructed the matrix for this gate <a class="reference external" href="https://learnquantum.io/chapters/01_classical_computing/01_03_bits_to_vectors.html#multi-bit-gates-and-circuits-as-matrices">before</a>, was by looking at the vectors for every combination of input and output qubits, and solving for each matrix element.</p>
<p>Alternatively, we can construct the unitary matrix of the <span class="math notranslate nohighlight">\(CX\)</span> gate by combining the gates acting on the target qubit (<span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(I\)</span>) with the projector operators (<span class="math notranslate nohighlight">\(\Pi_0\)</span> and <span class="math notranslate nohighlight">\(\Pi_1\)</span>) we introduced in <a class="reference external" href="https://learnquantum.io/chapters/02_quantum_computing/02_03_single_qb_sys.html#kets-bras-products-and-bases">the previous chapter</a>. For example, given the two-qubit state <span class="math notranslate nohighlight">\(|q_1 q_0\rangle\)</span>, we can construct a following 2-qubit operator that applies an <span class="math notranslate nohighlight">\(X\)</span> gate to <span class="math notranslate nohighlight">\(q_0\)</span> only if <span class="math notranslate nohighlight">\(q_1\)</span> is <span class="math notranslate nohighlight">\(|1\rangle\)</span> and add it to an operator that applies the identity <span class="math notranslate nohighlight">\(I\)</span> to <span class="math notranslate nohighlight">\(q_0\)</span> only if <span class="math notranslate nohighlight">\(q_1\)</span> is <span class="math notranslate nohighlight">\(|0\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
\begin{aligned}
CX &amp;= \Pi_0 \otimes I + \Pi_1 \otimes X
\\
\\
CX &amp;= |0\rangle \langle 0| \otimes I + |1\rangle \langle 1| \otimes X .
\end{aligned}
\end{split}\]</div>
<p>Consider the case in which we have <span class="math notranslate nohighlight">\(|q_1 q_0\rangle = |0\rangle \otimes |q_0\rangle\)</span>. The expectation is that a <span class="math notranslate nohighlight">\(CX\)</span> gate on this state, will result in applying an identity to the target qubit <span class="math notranslate nohighlight">\(|q_0\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
CX |q_1 q_0 \rangle &amp;= (|0\rangle \langle 0| \otimes I + |1\rangle \langle 1| \otimes X)|0\rangle \otimes |q_0\rangle
\\
\\
CX |q_1 q_0 \rangle &amp;= |0\rangle \langle 0|0\rangle \otimes I|q_0\rangle + |1\rangle \langle 1|0\rangle \otimes X|q_0\rangle
\\
\\
CX |q_1 q_0 \rangle &amp;= |0\rangle \otimes I|q_0\rangle .
\end{aligned}
\end{split}\]</div>
<p>We can follow the same procedure to show that, if <span class="math notranslate nohighlight">\(|q_1 q_0\rangle = |1\rangle \otimes |q_0\rangle\)</span> we will get <span class="math notranslate nohighlight">\(CX |q_1 q_0 \rangle = |1\rangle \otimes X|q_0\rangle\)</span>, as expected.</p>
<p>We can also show that the expression above for the <span class="math notranslate nohighlight">\(CX\)</span> gate does indeed give us the right matrix. Let’s use Qiskit to do this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">qiskit.quantum_info</span><span class="w"> </span><span class="kn">import</span> <span class="n">Operator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Π0</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">Π1</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>

<span class="n">CX</span> <span class="o">=</span> <span class="n">Π0</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">+</span> <span class="n">Π1</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">CX</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;CX = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
CX = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1  \\
 0 &amp; 0 &amp; 1 &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>As expected, the matrix above matches the unitary for the <span class="math notranslate nohighlight">\(CX\)</span> gate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;CX = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/3a568409b803d8c7c1f16e80813760906bee3432ef9cb788994e67a15521083a.png" src="../../_images/3a568409b803d8c7c1f16e80813760906bee3432ef9cb788994e67a15521083a.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
CX = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1  \\
 0 &amp; 0 &amp; 1 &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>What is convenient about the sum-of-operators representation we used above, is that we can replace the <span class="math notranslate nohighlight">\(X\)</span> gate with any other unitary <span class="math notranslate nohighlight">\(U\)</span>. For example, the controlled <span class="math notranslate nohighlight">\(Z\)</span> gate (<span class="math notranslate nohighlight">\(CZ\)</span>) applies a <span class="math notranslate nohighlight">\(Z\)</span> gate to the target qubit when the control qubit is in state <span class="math notranslate nohighlight">\(|1\rangle\)</span>. So we can construct its unitary operator as:</p>
<div class="math notranslate nohighlight">
\[ CZ = \Pi_0 \otimes I + \Pi_1 \otimes Z .\]</div>
<p>And again, let’s use Qiskit to look at the matrix for this gate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Z</span> <span class="o">=</span> <span class="n">Operator</span><span class="o">.</span><span class="n">from_label</span><span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span>

<span class="n">CZ</span> <span class="o">=</span> <span class="n">Π0</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">+</span> <span class="n">Π1</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
<span class="n">CZ</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;CZ = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
CZ = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; -1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>As we can see, this is a diagonal matrix, with ones in the diagonal, but for which the last entry has a value of <span class="math notranslate nohighlight">\(-1\)</span>. What this means is that, this unitary maps all two-qubit basis states to themselves, except for state <span class="math notranslate nohighlight">\(|11\rangle\)</span>, for which a phase of <span class="math notranslate nohighlight">\(-1\)</span> is introduced:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;|00\rangle \xrightarrow{\;\; \text{CZ} \;\;} \phantom{-}|00\rangle
\\
&amp;|01\rangle \xrightarrow{\;\; \text{CZ} \;\;} \phantom{-}|01\rangle
\\
&amp;|10\rangle \xrightarrow{\;\; \text{CZ} \;\;} \phantom{-}|10\rangle
\\
&amp;|11\rangle \xrightarrow{\;\; \text{CZ} \;\;} -|11\rangle
\end{aligned}
\end{split}\]</div>
<p>We can see this in action by placing a state in equal superposition and then applying the <span class="math notranslate nohighlight">\(CZ\)</span> gate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Statevector</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/2b3602049070e8096ed1a59a16505f619c2e1f90690251ec5eb7d9ccd78e5f3e.png" src="../../_images/2b3602049070e8096ed1a59a16505f619c2e1f90690251ec5eb7d9ccd78e5f3e.png" />
<div class="output text_latex math notranslate nohighlight">
\[\frac{1}{2} |00\rangle+\frac{1}{2} |01\rangle+\frac{1}{2} |10\rangle- \frac{1}{2} |11\rangle\]</div>
</div>
</div>
<p>An interesting observation is that the <span class="math notranslate nohighlight">\(CZ\)</span> gate is drawn without the typical “box” denoting the <span class="math notranslate nohighlight">\(Z\)</span> gate on <span class="math notranslate nohighlight">\(q_0\)</span> that is being controlled by <span class="math notranslate nohighlight">\(q_1\)</span>. This is because this gate is symmetric in the sense that swapping the control with the target qubit (i.e. making <span class="math notranslate nohighlight">\(q_0\)</span> the control and <span class="math notranslate nohighlight">\(q_1\)</span> the target) results in the same unitary matrix.</p>
<p>Similar to what we did with the <span class="math notranslate nohighlight">\(Z\)</span> gate, we can follow the same procedure for any other gate, like for example, parametrized gates such as a the controlled versions of <span class="math notranslate nohighlight">\(RX(\theta), RY(\theta), RZ(\varphi)\)</span>, or the controlled phase gate <span class="math notranslate nohighlight">\(CP(\varphi)\)</span>:</p>
<div class="math notranslate nohighlight">
\[ CP(\varphi) = \Pi_0 \otimes I + \Pi_1 \otimes P(\varphi) .\]</div>
<p>We can also easily construct controlled gates for which the control value that activates the target gate is different. For example we could implement a controlled-X gate, but where the <span class="math notranslate nohighlight">\(X\)</span> gets applied if the control qubit is in state <span class="math notranslate nohighlight">\(|0\rangle\)</span>. All we need to do is swap the projection operators in our definition:</p>
<div class="math notranslate nohighlight">
\[\overline{C}X = \Pi_1 \otimes I + \Pi_0 \otimes X .\]</div>
<p>The bar on top of the <span class="math notranslate nohighlight">\(C\)</span> is to express that the gate is activated when the control is in the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state rather than <span class="math notranslate nohighlight">\(|1\rangle\)</span>.</p>
<p>In Qiskit, one can switch the control condition of a <code class="docutils literal notranslate"><span class="pre">cx</span></code> gate by using the <code class="docutils literal notranslate"><span class="pre">ctrl_state</span></code> argument:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ctrl_state</span><span class="o">=</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">overline</span><span class="si">{C}</span><span class="s1"> X = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/b71b343e7909293ec4c4eab39f32374ac07cf03321571e058c4cca7739d711a2.png" src="../../_images/b71b343e7909293ec4c4eab39f32374ac07cf03321571e058c4cca7739d711a2.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\overline{C} X = 
\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 0  \\
 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>It is also worth noting that the above is equivalent to simply negating the control qubit before applying a conventional <span class="math notranslate nohighlight">\(CX\)</span> gate, and then negating it again to restore its original value:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">overline</span><span class="si">{C}</span><span class="s1"> X = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/b5e32db882f92f5d189bca22fd0e239e6c41de2b144717800b9734dee3fdb0a0.png" src="../../_images/b5e32db882f92f5d189bca22fd0e239e6c41de2b144717800b9734dee3fdb0a0.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\overline{C} X = 
\begin{bmatrix}
0 &amp; 1 &amp; 0 &amp; 0  \\
 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>We can then expand these ideas to more than just two qubits. Let us, for example, revisit the Toffoli (<span class="math notranslate nohighlight">\(CCX\)</span>) gate, where:</p>
<ol class="arabic simple">
<li><p>An <span class="math notranslate nohighlight">\(X\)</span> gate is applied to the target qubit if the control qubits are in state <span class="math notranslate nohighlight">\(|11\rangle\)</span>.</p></li>
<li><p>An <span class="math notranslate nohighlight">\(I\)</span> gate is applied to the target qubit if the control qubits are any other basis state, i.e. <span class="math notranslate nohighlight">\(|00\rangle, |01\rangle, |10\rangle\)</span>.</p></li>
</ol>
<p>Therefore, we express this unitary operation as:</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
\begin{aligned}
CCX &amp;= |00\rangle \langle 00| \otimes I +  |01\rangle \langle 01| \otimes I + |10\rangle \langle 10| \otimes I + |11\rangle \langle 11| \otimes X
\\
\\
CCX &amp;= (\Pi_{00} + \Pi_{01} + \Pi_{10}) \otimes I + \Pi_{11} \otimes X .
\end{aligned}
\end{split}\]</div>
<p>And of course, we can implement modifications of it, such as the case where the target gate gets activated when the control qubits are in, for example, state <span class="math notranslate nohighlight">\(|10\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[ C\overline{C}X = (\Pi_{00} + \Pi_{01} + \Pi_{11}) \otimes I + \Pi_{10} \otimes X .\]</div>
<p>In Qiskit, we use the same argument to specify the control state:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ctrl_state</span><span class="o">=</span><span class="s1">&#39;10&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;C\overline</span><span class="si">{C}</span><span class="s1">X = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/626238f0f2bf57307973cf867c21dafe95176d860b99e4dace10b83103c75d30.png" src="../../_images/626238f0f2bf57307973cf867c21dafe95176d860b99e4dace10b83103c75d30.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
C\overline{C}X = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Lastly, we can also use this representation of controlled gates to find the unitary matrix for when the control and target qubits are not adjacent. Let’s, for example, consider the case of a <span class="math notranslate nohighlight">\(CZ\)</span> where the control is on <span class="math notranslate nohighlight">\(|q_2\rangle\)</span> and the target on <span class="math notranslate nohighlight">\(|q_0\rangle\)</span> of a three-qubit system:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">idle_wires</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;CZ_</span><span class="si">{20}</span><span class="s1"> = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/de0d9fcbd01ae52b578f68626b797f86e7568535e8fb8019a5cab27866e8344a.png" src="../../_images/de0d9fcbd01ae52b578f68626b797f86e7568535e8fb8019a5cab27866e8344a.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
CZ_{20} = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>The way we would construct this matrix is by inserting an identity operator in between the tensor products of projection operators acting on the control qubit, and the target operators acting on the target qubit:</p>
<div class="math notranslate nohighlight">
\[ CZ_{20} = \Pi_0 \otimes \underset{\substack{\uparrow}}I \otimes I + \Pi_1 \otimes \underset{\substack{\uparrow}}I \otimes Z .\]</div>
</section>
<section id="the-swap-gate">
<h4>2.2.2 The SWAP Gate<a class="headerlink" href="#the-swap-gate" title="Link to this heading">#</a></h4>
<p>Another important entangling gate is the <span class="math notranslate nohighlight">\(\text{SWAP}\)</span> gate, which literally swaps the state between two qubits:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
|00\rangle \xrightarrow{\;\; \text{SWAP} \;\;} |00\rangle
\\
|01\rangle \xrightarrow{\;\; \text{SWAP} \;\;} |10\rangle
\\
|10\rangle \xrightarrow{\;\; \text{SWAP} \;\;} |01\rangle
\\
|11\rangle \xrightarrow{\;\; \text{SWAP} \;\;} |11\rangle
\end{aligned}
\end{split}\]</div>
<p>We can generate its corresponding unitary matrix for this operation using Qiskit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">text</span><span class="si">{SWAP}</span><span class="s1"> = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/b84a84e9a58c943906ed9bce01cb9f4ea1c29003d93b7aaab52188796c4cb173.png" src="../../_images/b84a84e9a58c943906ed9bce01cb9f4ea1c29003d93b7aaab52188796c4cb173.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\text{SWAP} = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>A <span class="math notranslate nohighlight">\(\text{SWAP}\)</span> gate can be in fact decomposed into three <span class="math notranslate nohighlight">\(CX\)</span> gates as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">text</span><span class="si">{SWAP}</span><span class="s1"> = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/bbb5381cf300fcf0ac0d385157e32634b1275f2f8d34ec156da22f860dfac793.png" src="../../_images/bbb5381cf300fcf0ac0d385157e32634b1275f2f8d34ec156da22f860dfac793.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
\text{SWAP} = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>The logic for why this works is the same as that of the <a class="reference external" href="https://en.wikipedia.org/wiki/XOR_swap_algorithm">XOR SWAP trick</a> used in computer programming (recall that a <span class="math notranslate nohighlight">\(CX\)</span> gate is equivalent to reversible <span class="math notranslate nohighlight">\(\mathsf{XOR}\)</span>).</p>
<p>The controlled version of a <span class="math notranslate nohighlight">\(\text{SWAP}\)</span> gate (<span class="math notranslate nohighlight">\(C\text{SWAP}\)</span>) is also known as the <a class="reference external" href="https://en.wikipedia.org/wiki/Fredkin_gate">Fredkin gate</a>, and basically swaps two qubits conditioned on the state of a third (control) qubit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cswap</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;C </span><span class="se">\\</span><span class="s1">text</span><span class="si">{SWAP}</span><span class="s1"> = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/2b82395e9ce9ece2eb213bb7ee749bbcea6dc48390df5a84b1c79aec8fc76dff.png" src="../../_images/2b82395e9ce9ece2eb213bb7ee749bbcea6dc48390df5a84b1c79aec8fc76dff.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
C \text{SWAP} = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
</section>
</section>
<section id="the-copy-gate-no-cloning-theorem">
<h3>2.3 The Copy Gate (No-Cloning Theorem)<a class="headerlink" href="#the-copy-gate-no-cloning-theorem" title="Link to this heading">#</a></h3>
<p>An operation we introduced in the chapter on reversible classical computing was one with the ability to copy the value of a bit (say, <span class="math notranslate nohighlight">\(b_1\)</span>) to another (e.g., <span class="math notranslate nohighlight">\(b_0\)</span>) by the use of a <span class="math notranslate nohighlight">\(CX\)</span> gate. Since qubits that are in strictly one of the two computational basis states <span class="math notranslate nohighlight">\(\{|0\rangle, |1\rangle \}\)</span> behave just like classical bits, we can effectively copy a qubit in the same way:</p>
<a class="reference internal image-reference" href="../../_images/02_04_01_copy_1.png"><img alt="../../_images/02_04_01_copy_1.png" class="align-center" src="../../_images/02_04_01_copy_1.png" style="width: 420px;" />
</a>
<p>So, given two qubits <span class="math notranslate nohighlight">\(|q_1\rangle, |q_0\rangle\)</span>, we can copy the state of <span class="math notranslate nohighlight">\(|q_1\rangle\)</span> onto <span class="math notranslate nohighlight">\(|q_0\rangle\)</span> using a <span class="math notranslate nohighlight">\(CX\)</span> gate, provided that <span class="math notranslate nohighlight">\(|q_0\rangle\)</span> is initialized at <span class="math notranslate nohighlight">\(|0\rangle\)</span>, and the state of <span class="math notranslate nohighlight">\(|q_1\rangle\)</span> (denoted as <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>) is one of the computational basis states:</p>
<div class="math notranslate nohighlight">
\[ |q_1 q_0\rangle = |\psi \rangle \otimes |0\rangle \xrightarrow{\; CX \;} |\psi \rangle \otimes |\psi \rangle, \; \text{ provided} \; |\psi \rangle \in \{|0\rangle, |1\rangle\} .\]</div>
<p>The question then is, can we construct a copy gate <span class="math notranslate nohighlight">\(\Theta\)</span> that, given the general qubit state <span class="math notranslate nohighlight">\(|\psi\rangle \in \mathcal{H}_2\)</span>, produces the exact same state on an another qubit?</p>
<a class="reference internal image-reference" href="../../_images/02_04_01_copy_2.png"><img alt="../../_images/02_04_01_copy_2.png" class="align-center" src="../../_images/02_04_01_copy_2.png" style="width: 420px;" />
</a>
<p>In other words, what we want is for <span class="math notranslate nohighlight">\(\Theta\)</span> to take a general superposition state <span class="math notranslate nohighlight">\(|\psi\rangle = \alpha_0|0\rangle + \alpha_1|1\rangle\)</span> and copy it from one qubit to another as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
|\psi\rangle \otimes |0\rangle &amp;\xrightarrow{\; \Theta \; \,} |\psi\rangle \otimes |\psi\rangle
\\
\\
(\alpha_0|0\rangle + \alpha_1|1\rangle) \otimes |0\rangle &amp;\xrightarrow{\; \Theta \; \,} (\alpha_0|0\rangle + \alpha_1|1\rangle) \otimes (\alpha_0|0\rangle + \alpha_1|1\rangle)
\\
\\
\alpha_0|00\rangle + \alpha_1|10\rangle &amp;\xrightarrow{\; \Theta \; \,} \alpha_0^2|00\rangle + \alpha_0\alpha_1|01\rangle + \alpha_1\alpha_0|10\rangle + \alpha_1^2|11\rangle .
\end{aligned}
\end{split}\]</div>
<p>We can show that this copy operation is indeed satisfied for the basis states. For the case in which we want to copy state <span class="math notranslate nohighlight">\(|0\rangle\)</span>, we have <span class="math notranslate nohighlight">\(\alpha_0 = 1\)</span> and <span class="math notranslate nohighlight">\(\alpha_1 = 0\)</span>, which correctly results in:</p>
<div class="math notranslate nohighlight">
\[ |00\rangle \xrightarrow{\; \Theta \; \,} |00\rangle \]</div>
<p>And for the case in which we want to copy state <span class="math notranslate nohighlight">\(|1\rangle\)</span>, we instead have <span class="math notranslate nohighlight">\(\alpha_0 = 0\)</span> and <span class="math notranslate nohighlight">\(\alpha_1 = 1\)</span>, which results in:</p>
<div class="math notranslate nohighlight">
\[ |10\rangle \xrightarrow{\; \Theta \; \,} |11\rangle \]</div>
<p>However, since unitary operations are linear, passing a superposition of states <span class="math notranslate nohighlight">\(|00\rangle\)</span> and <span class="math notranslate nohighlight">\(|10\rangle\)</span> through <span class="math notranslate nohighlight">\(\Theta\)</span> should result in a superposition of states <span class="math notranslate nohighlight">\(|00\rangle\)</span> and <span class="math notranslate nohighlight">\(|11\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\alpha_0|00\rangle + \alpha_1|10\rangle \xrightarrow{\; \Theta \; \,} \alpha_0|00\rangle + \alpha_1|11\rangle . \]</div>
<p>This result then places a strong constraint on the values <span class="math notranslate nohighlight">\(\alpha_0\)</span> and <span class="math notranslate nohighlight">\(\alpha_1\)</span> can take. Equating this output expression with the one we got for the general copying operation we get:</p>
<div class="math notranslate nohighlight">
\[\alpha_0|00\rangle + \alpha_1|11\rangle = \alpha_0^2|00\rangle + \alpha_0\alpha_1|01\rangle + \alpha_1\alpha_0|10\rangle + \alpha_1^2|11\rangle, \]</div>
<p>which <strong>only</strong> holds for when <span class="math notranslate nohighlight">\((\alpha_0 = 1, \alpha_1 = 0)\)</span> or <span class="math notranslate nohighlight">\((\alpha_1 = 0, \alpha_1 = 1)\)</span>, but not otherwise. However, what we wanted was for <span class="math notranslate nohighlight">\(\Theta\)</span> to be able to copy a state for any possible value of <span class="math notranslate nohighlight">\(\alpha_0\)</span> and <span class="math notranslate nohighlight">\(\alpha_1\)</span>!</p>
<p>This impossibility of copying an arbitrary state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> is known as the <a class="reference external" href="https://en.wikipedia.org/wiki/No-cloning_theorem">non-cloning theorem</a>, and it is one of the most important results in the field of quantum information.</p>
</section>
<section id="universal-gate-sets">
<h3>2.4 Universal Gate Sets<a class="headerlink" href="#universal-gate-sets" title="Link to this heading">#</a></h3>
<p>An important aspect about quantum computing is that, depending on the type of hardware implementation (e.g. superconducting qubits, ion traps, etc.), the gates available to construct our circuits is limited to a subset of operations known as the basis gate-set. A gate-set that can implement any other unitary with arbitrary precision is known as a <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates">universal gate-set</a>.</p>
<p>In most of today’s quantum devices, basis gate-sets are composed of one-qubit and two-qubit gates. Furthermore, the majority of these systems allow for continous-valued parametrized gates in one or more of their basis gates. This enables the precise control needed to build any other unitary gate or circuit. For instance, a valid gate-set could be composed of the gates <span class="math notranslate nohighlight">\(\{CX, SX, RZ(\theta) \}\)</span>, where the <span class="math notranslate nohighlight">\(RZ\)</span> gate is parameterized by an angle <span class="math notranslate nohighlight">\(\theta\)</span> that can take continuous values.</p>
<p>Let’s take as an example a Toffoli (<span class="math notranslate nohighlight">\(CCX\)</span>) gate, which is a 3-qubit gate. This gate would have to be decomposed into gates that belong to the gate-set above in order to run on a particular quantum processor. Here is an example in Qiskit of how the <span class="math notranslate nohighlight">\(CCX\)</span> gate can be represented in terms of these gates:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">qiskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">transpile</span> 
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>

<span class="n">qc_t</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cx&#39;</span><span class="p">,</span> <span class="s1">&#39;sx&#39;</span><span class="p">,</span> <span class="s1">&#39;rz&#39;</span><span class="p">])</span> <span class="c1"># Converts arbitrary circuit to a given basis gate-set</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc_t</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>

<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;CCX = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/03a06d6d20e565ae1941fc310627a47513eae883d38dccfa087aaa089f6214f0.png" src="../../_images/03a06d6d20e565ae1941fc310627a47513eae883d38dccfa087aaa089f6214f0.png" />
<img alt="../../_images/4a01bdfb55534fb816bf073978f683c49ec5f863d63ce511fa3907239c215b60.png" src="../../_images/4a01bdfb55534fb816bf073978f683c49ec5f863d63ce511fa3907239c215b60.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
CCX = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Since quantum operations in current state-of-the-art devices are still very prone to noise, minimizing the number of gates in a circuit is of extreme importance. As the field advances, circuit compilers–which are responsible of translating an arbitrary circuit onto the basis gate-set of some specific hardware–are continuously improving at generating optimized circuits. However, it is always important to make sure that every circuit is application-aware, meaning that we always try to implement circuits that minimize the number of basis gates.</p>
<p>Here’s a clear example. The Toffoli gate (<span class="math notranslate nohighlight">\(CCX\)</span>) flips a target qubit whenever both of the control qubits are in state <span class="math notranslate nohighlight">\(|1\rangle\)</span>. However, it does so without introducing a relative phase between different basis states. In certain applications, adding a relative phase might not be detrimental to the final computation, so we could use another circuit that uses less gates than a <span class="math notranslate nohighlight">\(CCX\)</span> gate. The <a class="reference external" href="https://en.wikipedia.org/wiki/Toffoli_gate#Related_logic_gates">Margolus gate</a> (also known as the simplified Toffoli, or relative-phase-Toffoli, or <span class="math notranslate nohighlight">\(RCCX\)</span> gate), is precisely an example of this. It acts like the <span class="math notranslate nohighlight">\(CCX\)</span>, but respectively adds phases of <span class="math notranslate nohighlight">\(-1, i, -i\)</span> to states <span class="math notranslate nohighlight">\(|101\rangle, |110\rangle, |111\rangle\)</span>. The advantage though is that it requires a significantly less number of basis gates to implement.</p>
<p>The code below in shows the decomposed Margolus gate onto the <span class="math notranslate nohighlight">\(\{CX, SX, RZ(\theta) \}\)</span> gate-set. It can be seen that the number of required gates is significantly smaller than what we had for the <span class="math notranslate nohighlight">\(CCX\)</span> gate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rccx</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>

<span class="n">qc_t</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">basis_gates</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cx&#39;</span><span class="p">,</span> <span class="s1">&#39;sx&#39;</span><span class="p">,</span> <span class="s1">&#39;rz&#39;</span><span class="p">])</span> <span class="c1"># Converts arbitrary circuit to a given basis gate-set</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc_t</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>

<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;RCCX = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/410dc15059e59514a3280cac3998bb1d62251d026fb257fd0d5328a44b97f465.png" src="../../_images/410dc15059e59514a3280cac3998bb1d62251d026fb257fd0d5328a44b97f465.png" />
<img alt="../../_images/4bbe1930909bc43867540810abf9958a61cef2133bd33d5b5cc23227b40555fc.png" src="../../_images/4bbe1930909bc43867540810abf9958a61cef2133bd33d5b5cc23227b40555fc.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
RCCX = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; - i  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; i &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>Now, allowing for continuous-valued parameters has limitations in terms of noise robustness and implementation complexity/efficiency in <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_error_correction">error-corrected</a> <a class="reference external" href="https://en.wikipedia.org/wiki/Threshold_theorem">fault-tolerant</a> architectures. Therefore, in the long run, basis gate-sets composed of fixed-angle gates are desirable.</p>
<p>A common set to do this is the Clifford+T gate-set. This set of gates is <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates">universal</a>, meaning that it can be used to approximate any unitary up to arbitrary precision. The set is composed by the <a class="reference external" href="https://en.wikipedia.org/wiki/Clifford_gates">Clifford gates</a> <span class="math notranslate nohighlight">\(\{H, S, CX\}\)</span>, and the <span class="math notranslate nohighlight">\(T\)</span> gate, which we covered in the previous chapter. Clifford gates on their own have been proven to be easy to simulate classically by <a class="reference external" href="https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem">Gottesman–Knill theorem</a> but, surprisingly, adding a <span class="math notranslate nohighlight">\(T\)</span> gate enables full quantum-computational power. The reason why this is the case is explained by the <a class="reference external" href="https://en.wikipedia.org/wiki/Solovay%E2%80%93Kitaev_theorem">Solovay–Kitaev theorem</a>, the details of which are outside of the scope of our discussion.</p>
<p>Here is an example of how a <span class="math notranslate nohighlight">\(CCX\)</span> gate can be constructed out of the Clifford+T gate-set:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">tdg</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">tdg</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">tdg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
<span class="n">Operator</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;CCX = &#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/08658dfb5e8a8c216d983261f836710e3c79f49e792f206da3768acf946b1751.png" src="../../_images/08658dfb5e8a8c216d983261f836710e3c79f49e792f206da3768acf946b1751.png" />
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
CCX = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1  \\
 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
</div>
</div>
<p>In most error correction architectures, the implementation of a <span class="math notranslate nohighlight">\(T\)</span> gate is selected to be the most expensive part of the computation, meaning that it takes a significantly larger number of physical operations to execute a <span class="math notranslate nohighlight">\(T\)</span> (or <span class="math notranslate nohighlight">\(T^{\dagger}\)</span>) gate than a Clifford gate <span class="math notranslate nohighlight">\(\{H, CX \} .\)</span> Therefore, minimizing what is known as the <span class="math notranslate nohighlight">\(T\)</span>-depth of a circuit is usually of great importance. We will discuss the reasons behind this in a later chapter when we discuss error correction and fault-tolerant computing.</p>
<p>The <span class="math notranslate nohighlight">\(T\)</span>-depth is estimated by “layering” all the <span class="math notranslate nohighlight">\(\{T, T^{\dagger} \}\)</span> gates in separate qubits that can be executed in parallel, and counting the total number of these layers. For example, in the circuit above, the first <span class="math notranslate nohighlight">\(T\)</span> gate that appears on <span class="math notranslate nohighlight">\(q_0\)</span> can be executed in parallel with the <span class="math notranslate nohighlight">\(T\)</span> gate on <span class="math notranslate nohighlight">\(q_2\)</span>, so the total number of <span class="math notranslate nohighlight">\(T\)</span>-gate layers will be 4. Here is how we can extract the <span class="math notranslate nohighlight">\(T\)</span>-depth of a circuit in Qiskit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">T_depth</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="k">lambda</span> <span class="n">instr</span><span class="p">:</span> <span class="n">instr</span><span class="o">.</span><span class="n">operation</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;tdg&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;T-depth of CCX circuit: &quot;</span><span class="p">,</span> <span class="n">T_depth</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T-depth of CCX circuit:  4
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="multi-qubit-measurements">
<h2>3. Multi-Qubit Measurements<a class="headerlink" href="#multi-qubit-measurements" title="Link to this heading">#</a></h2>
<section id="full-state-measurement">
<h3>3.1 Full State Measurement<a class="headerlink" href="#full-state-measurement" title="Link to this heading">#</a></h3>
<p>Just like we did for single qubit states, we compute the probability of measuring one of the possible outcomes for a multi-qubit state by using the Born rule; i.e., by taking the norm squared of the probability amplitude associated with the outcome state of interest. So, for a state of the form:</p>
<div class="math notranslate nohighlight">
\[ |q\rangle = \sum_{j=0}^{N-1} \alpha_{j} |j\rangle, \]</div>
<p>the probability of measuring the <span class="math notranslate nohighlight">\(j^{th}\)</span> basis state <span class="math notranslate nohighlight">\(|j\rangle\)</span> is given by:</p>
<div class="math notranslate nohighlight">
\[\mathbb{P}_j = \langle q | \Pi_{j} | q \rangle = |\alpha_j|^2 , \text{ where: } \; \Pi_{j} = | j \rangle \langle j | .\]</div>
<p>If a measurement results in the classical outcome <span class="math notranslate nohighlight">\(j\)</span>, the quantum state will be projected from the superpositon state <span class="math notranslate nohighlight">\(|q\rangle\)</span> shown above, to the basis state <span class="math notranslate nohighlight">\(|j\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[ |q'\rangle = \frac{1}{\sqrt{\mathbb{P}_j}} \Pi_{j} |q\rangle .\]</div>
<p>For example, given the superposition state:</p>
<div class="math notranslate nohighlight">
\[ |\textit{w}\rangle = \frac{1}{\sqrt{3}}|001\rangle + \frac{i}{\sqrt{3}}|010\rangle - \frac{1}{\sqrt{3}}|100\rangle, \]</div>
<p>The probability of measuring each of the three possible basis states is:</p>
<div class="math notranslate nohighlight">
\[
\mathbb{P}_{001} = \left|\frac{1}{\sqrt{3}}\right|^2  = \frac{1}{3}, \quad
\mathbb{P}_{010} = \left|\frac{i}{\sqrt{3}}\right|^2  = \frac{1}{3}, \quad
\mathbb{P}_{100} = \left|\frac{-1}{\sqrt{3}}\right|^2  = \frac{1}{3}.
\]</div>
<p>Furthermore, performing a measurement on superposition state above will project it into only one of the three possible states as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}|\textit{w}\rangle = \frac{1}{\sqrt{3}}|001\rangle + \frac{i}{\sqrt{3}}|010\rangle - \frac{1}{\sqrt{3}}|100\rangle \xrightarrow{measure} |\textit{w}'\rangle =
\begin{cases}
|001\rangle \text{, with prob: } \mathbb{P}_{001} \\ \\
|010\rangle \text{, with prob: } \mathbb{P}_{010} \\ \\
|100\rangle \text{, with prob: } \mathbb{P}_{100}
\end{cases}
\\
\end{split}\]</div>
<p>We can look this example in Qiskit by creating a <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> object and using the <code class="docutils literal notranslate"><span class="pre">probabilites</span></code> method to verify that indeed the array of probabilities we get correspond to the norm square of the probability amplitudes. We can also use the <code class="docutils literal notranslate"><span class="pre">measure</span></code> method to project a superposition state into one of the possible outcomes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create 3-qubit |w⟩ state:</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Statevector</span><span class="o">.</span><span class="n">from_int</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">Statevector</span><span class="o">.</span><span class="n">from_int</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_int</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="c1"># Display statevector in vector notation</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Statevector:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;|</span><span class="se">\\</span><span class="s1">textit</span><span class="si">{w}</span><span class="se">\\</span><span class="s1">rangle =&#39;</span><span class="p">))</span>

<span class="c1"># Display statevector in vector notation</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Probability Amplitudes:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">convention</span><span class="o">=</span><span class="s1">&#39;vector&#39;</span><span class="p">))</span>

<span class="c1"># Print probabilities of measuring each basis state</span>
<span class="n">probs</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">probabilities</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Probabilities:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">))</span>

<span class="c1"># Measure state once (results differ with every run)</span>
<span class="n">c_result</span><span class="p">,</span> <span class="n">q_result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-Measurement Projected State:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">q_result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-Measurement Classical Outcome:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Statevector:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[|\textit{w}\rangle =\frac{\sqrt{3}}{3} |001\rangle+\frac{\sqrt{3} i}{3} |010\rangle- \frac{\sqrt{3}}{3} |100\rangle\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Probability Amplitudes:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
0 &amp; \frac{\sqrt{3}}{3} &amp; \frac{\sqrt{3} i}{3} &amp; 0 &amp; - \frac{\sqrt{3}}{3} &amp; 0 &amp; 0 &amp; 0  \\
 \end{bmatrix}
\end{split}\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Probabilities:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \left[\begin{matrix}0 &amp; \frac{1}{3} &amp; \frac{1}{3} &amp; 0 &amp; \frac{1}{3} &amp; 0 &amp; 0 &amp; 0\end{matrix}\right]\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Single-Measurement Projected State:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[ |001\rangle\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Single-Measurement Classical Outcome:

001
</pre></div>
</div>
</div>
</div>
<p>Alternatively to using the <code class="docutils literal notranslate"><span class="pre">Statevector</span></code> class methods described above, we can also create a circuit that prepares the desired state and add measurement blocks to sample its output. We would then need a simulator to execute the circuit and extract its output:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># prepare |w⟩</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cry</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)),</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cry</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="n">qc</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># measure all qubits</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="c1"># Save statevector after performing measurement</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_statevector</span><span class="p">()</span> 
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/f957bed879af2d27e196a388b1d04a221922a48ceab61680d7a7928b3a08cea8.png" src="../../_images/f957bed879af2d27e196a388b1d04a221922a48ceab61680d7a7928b3a08cea8.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">qiskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">transpile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qiskit.visualization</span><span class="w"> </span><span class="kn">import</span> <span class="n">plot_distribution</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">qiskit_aer</span><span class="w"> </span><span class="kn">import</span> <span class="n">AerSimulator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run simulation</span>
<span class="n">simulator</span> <span class="o">=</span> <span class="n">AerSimulator</span><span class="p">()</span>
<span class="n">qc_t</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">simulator</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_t</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="c1"># Extract projected statevector for one measurement</span>
<span class="n">w_meas</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
<span class="n">display</span><span class="p">(</span><span class="n">w_meas</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[- |100\rangle\]</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract samples from running circuit 1000 times</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_distribution</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/1a22cd3d5e188e45078e3e5a125214a9c6a2613a660d3f364711c44814dd5f20.png" src="../../_images/1a22cd3d5e188e45078e3e5a125214a9c6a2613a660d3f364711c44814dd5f20.png" />
</div>
</div>
</section>
<section id="partial-state-measurement">
<h3>3.2 Partial State Measurement<a class="headerlink" href="#partial-state-measurement" title="Link to this heading">#</a></h3>
<p>The process described above works well when we are measuring the totality of qubits for a given statevector. However, a couple of interesting questions arise when dealing with multi-qubit systems:</p>
<ol class="arabic simple">
<li><p>How do we compute the probability of only measuring part of the state?</p></li>
<li><p>What would the resulting statevector be after this measurement takes place?</p></li>
</ol>
<p>In other words, what is the procedure to follow if we measure only <span class="math notranslate nohighlight">\(m\)</span> qubits out of a system with a total <span class="math notranslate nohighlight">\(n\)</span> qubits (where <span class="math notranslate nohighlight">\(m &lt; n\)</span>)?</p>
<p>The first thing to note is that, we can rewrite the expression for any multi-qubit superposition state as a sum of Kronecker products of the qubits that will be measured (let’s call these subsystem <span class="math notranslate nohighlight">\(A\)</span>), and the ones that will <strong>not</strong> be measured (let’s call these subsystem <span class="math notranslate nohighlight">\(B\)</span>). For example, going back to the <span class="math notranslate nohighlight">\(|\textit{w}\rangle\)</span> state we defined above, if we are planning to measure just the least significant qubit, we can rewrite the state as:</p>
<div class="math notranslate nohighlight">
\[ |\textit{w}\rangle = \frac{1}{\sqrt{3}}|00\rangle_B \otimes |1\rangle_A + \frac{i}{\sqrt{3}}|01\rangle_B \otimes |0\rangle_A - \frac{1}{\sqrt{3}}|10\rangle_B \otimes |0\rangle_A. \]</div>
<p>Now, since <span class="math notranslate nohighlight">\(|0\rangle_A\)</span> appears twice in this expression, we can factorize it to get:</p>
<div class="math notranslate nohighlight">
\[ |\textit{w}\rangle = \left( \frac{1}{\sqrt{3}}|00\rangle_B \right) \otimes |1\rangle_A + \left( \frac{i}{\sqrt{3}}|01\rangle_B - \frac{1}{\sqrt{3}}|10\rangle_B \right) \otimes  |0\rangle_A .\]</div>
<p>This makes it clear that, there are two states from subsystem <span class="math notranslate nohighlight">\(B\)</span> associated with <span class="math notranslate nohighlight">\(|0\rangle_A\)</span>, and only one state of <span class="math notranslate nohighlight">\(B\)</span> associated with <span class="math notranslate nohighlight">\(|1\rangle_A\)</span>. So to calculate the probability of individually measuring the outcomes of subsystem <span class="math notranslate nohighlight">\(A\)</span>, we must add the number of possible ways we can obtain each outcome, weighted by the modulus squared of the corresponding probability amplitudes:</p>
<div class="math notranslate nohighlight">
\[ \mathbb{P}^A_0 = \left|\frac{i}{\sqrt{3}} \right|^2 + \left|\frac{-1}{\sqrt{3}} \right|^2 = \frac{2}{3}, \quad \text{ and } \quad  \mathbb{P}^A_1 = \left|\frac{1}{\sqrt{3}} \right|^2 = \frac{1}{3} .\]</div>
<p>From the expression for <span class="math notranslate nohighlight">\(|\textit{w}\rangle\)</span>, it is also evident that, if a measurement on subsystem <span class="math notranslate nohighlight">\(A\)</span> results in <span class="math notranslate nohighlight">\(0\)</span>, the projected state will be:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
|\textit{w'}_0\rangle &amp;= \left( \frac{i}{\sqrt{3}}|01\rangle_B - \frac{1}{\sqrt{3}}|10\rangle_B \right)\otimes  |0\rangle_A 
\\
\\
|\textit{w'}_0\rangle &amp;= \frac{i}{\sqrt{3}}|010\rangle - \frac{1}{\sqrt{3}}|100\rangle.
\end{aligned}
\end{split}\]</div>
<p>Mathematically, we could extract this statevector by applying the projector operator <span class="math notranslate nohighlight">\(\Pi_0\)</span> on subsystem <span class="math notranslate nohighlight">\(A\)</span> (to select <span class="math notranslate nohighlight">\(|0\rangle_A\)</span>), and an identity operator on subsystem <span class="math notranslate nohighlight">\(B\)</span> (to leave that portion of the total state unchanged). So, the operator acting on the whole system is:</p>
<div class="math notranslate nohighlight">
\[ \Pi_0^A = I_B \otimes \Pi_0, \]</div>
<p>where <span class="math notranslate nohighlight">\(I_B = I \otimes I\)</span> (since subsystem <span class="math notranslate nohighlight">\(B\)</span> is composed of 2 qubits), we have that:</p>
<div class="math notranslate nohighlight">
\[ |\textit{w'}_0\rangle = \Pi_0^A|\textit{w}\rangle .\]</div>
<p>However, an issue with state <span class="math notranslate nohighlight">\(|\textit{w'}_0\rangle\)</span> is that it is not properly normalized. This is because the sum of the modulus squared of its probability amplitudes is not equal to <span class="math notranslate nohighlight">\(1\)</span>. So, to normalize this statevector, we need to divide it by its vector length, which as we saw in the <a class="reference external" href="https://learnquantum.io/chapters/02_quantum_computing/02_03_single_qb_sys.html#kets-bras-products-and-bases">previous chapter</a>, can be computed for <span class="math notranslate nohighlight">\(|\textit{w'}_0\rangle\)</span> as:</p>
<div class="math notranslate nohighlight">
\[ \|\textit{w'}_0\| = \sqrt{\langle \textit{w'}_0|\textit{w'}_0\rangle}, \]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\langle \textit{w'}_0|\textit{w'}_0\rangle &amp;= \left(\frac{-i}{\sqrt{3}}\langle 010| - \frac{1}{\sqrt{3}}\langle 100| \right)\left(\frac{i}{\sqrt{3}}|010\rangle - \frac{1}{\sqrt{3}}|100\rangle \right)
\\
\\
\langle \textit{w'}_0|\textit{w'}_0\rangle &amp;= \left|\frac{i}{\sqrt{3}}\right|^2 + \left|\frac{-1}{\sqrt{3}}\right|^2
\\
\\
\langle \textit{w'}_0|\textit{w'}_0\rangle &amp;= \frac{2}{3}
\end{aligned}
\end{split}\]</div>
<p>Upon close inspection, we can see that <span class="math notranslate nohighlight">\(\langle \textit{w'}_0|\textit{w'}_0\rangle\)</span> is in fact the same as the probability of measuring <span class="math notranslate nohighlight">\(0\)</span> on subsystem <span class="math notranslate nohighlight">\(A\)</span> we calculated before:</p>
<div class="math notranslate nohighlight">
\[ \mathbb{P}_0^A = \langle \textit{w'}_0|\textit{w'}_0\rangle = \frac{2}{3} ,\]</div>
<p>which we can also write in terms of the original statevector <span class="math notranslate nohighlight">\(|\textit{w}\rangle\)</span> and the projection operator as:</p>
<div class="math notranslate nohighlight">
\[ \mathbb{P}_0^A = \langle \textit{w}| \Pi_{0}^A |\textit{w}\rangle .\]</div>
<p>So, the equation to calculate the normalized state vector is:</p>
<div class="math notranslate nohighlight">
\[ |\textit{w}_0'\rangle = \frac{1}{\sqrt{\mathbb{P}_0^A}} \Pi_{0}^A |\textit{w}\rangle, \]</div>
<p>which will then result in:</p>
<div class="math notranslate nohighlight">
\[\begin{split} 
\begin{aligned}
|\textit{w}_0'\rangle &amp;= \frac{1}{\sqrt{2/3}} \left(\frac{i}{\sqrt{3}}|010\rangle - \frac{1}{\sqrt{3}}|100\rangle \right)
\\
\\
|\textit{w}_0'\rangle &amp;= \frac{i}{\sqrt{2}}|010\rangle - \frac{1}{\sqrt{2}}|100\rangle
\end{aligned}
\end{split}\]</div>
<p>We can of course do the same for when we measure a <span class="math notranslate nohighlight">\(1\)</span> in subsystem <span class="math notranslate nohighlight">\(A\)</span>. The projected state in this case would be:</p>
<div class="math notranslate nohighlight">
\[ |\textit{w'}_1\rangle = \frac{1}{\sqrt{\mathbb{P}_1^A}} \Pi_1^A|\textit{w}\rangle , \]</div>
<p>where:</p>
<div class="math notranslate nohighlight">
\[ \Pi_1^A = I_B \otimes \Pi_1 \quad \text{and} \quad \mathbb{P}_1^A = \langle \textit{w}| \Pi_{1}^A |\textit{w}\rangle .\]</div>
<p>Which, again, correctly results in state:</p>
<div class="math notranslate nohighlight">
\[|\textit{w'}_1\rangle = |001\rangle. \]</div>
<p>So, given a state <span class="math notranslate nohighlight">\(|q\rangle\)</span> with <span class="math notranslate nohighlight">\(n\)</span> qubits, if we want to calculate the probabilities and post-measurement statevectors associated with the outcomes of measuring the first <span class="math notranslate nohighlight">\(m\)</span> qubits (call this subsystem <span class="math notranslate nohighlight">\(A\)</span>), we need to define a set of projection operators <span class="math notranslate nohighlight">\(\Pi_k^A\)</span>, with <span class="math notranslate nohighlight">\(k \in [0, 2^m-1]\)</span> of the form:</p>
<div class="math notranslate nohighlight">
\[\Pi_k^A = I^{\otimes(n-m)} \otimes \Pi_k , \; \text{ where: } \; \Pi_k = |k\rangle\langle k|.\]</div>
<p>The probability of measuring the <span class="math notranslate nohighlight">\(k^{\text{th}}\)</span> basis state of subsystem <span class="math notranslate nohighlight">\(A\)</span> is then given by:</p>
<div class="math notranslate nohighlight">
\[\mathbb{P}_k^A = \langle q | \Pi_k^A | q \rangle, \]</div>
<p>and the corresponding projected state can be computed as:</p>
<div class="math notranslate nohighlight">
\[ |q'\rangle = \frac{1}{\sqrt{\mathbb{P}_k^A}} \Pi_k^A |q\rangle .\]</div>
<p>This procedure can be generalized for when the qubits to be measured are not the fist <span class="math notranslate nohighlight">\(m\)</span> qubits of the state by breaking down the projection operator <span class="math notranslate nohighlight">\(\Pi_k\)</span> into the individual projection matrices of each qubit, and inserting identity matrices wherever there is a qubit that is not being measured. For example, if we have a system with 5 qubits, and we want to compute the projection operator for measuring a <span class="math notranslate nohighlight">\(0\)</span> in qubit <span class="math notranslate nohighlight">\(q_0\)</span> and a <span class="math notranslate nohighlight">\(1\)</span> in qubit <span class="math notranslate nohighlight">\(q_2\)</span>, the projection operator for this would be:</p>
<div class="math notranslate nohighlight">
\[\Pi_{10}^A = I \otimes I \otimes \Pi_1 \otimes I \otimes \Pi_0 . \]</div>
<p>In Qiskit, it is easy enough to get the probabilities and projection states of a partial measurement by using the same methods we used above, but now specifying which qubits we want to measure. Let’s use the same example for the <span class="math notranslate nohighlight">\(|\textit{w}\rangle\)</span> state we used before, where we only measure the least significant qubit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create 3-qubit |w⟩ state:</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Statevector</span><span class="o">.</span><span class="n">from_int</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">Statevector</span><span class="o">.</span><span class="n">from_int</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="n">Statevector</span><span class="o">.</span><span class="n">from_int</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="c1"># Display statevector in vector notation</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Statevector:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">&#39;latex&#39;</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;|</span><span class="se">\\</span><span class="s1">textit</span><span class="si">{w}</span><span class="se">\\</span><span class="s1">rangle =&#39;</span><span class="p">))</span>

<span class="c1"># Print probabilities of measuring only the least-significant qubit</span>
<span class="n">probs</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">probabilities</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Probabilities of measuring 0 or 1 in q0:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">applyfunc</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">nsimplify</span><span class="p">))</span>

<span class="c1"># Measure least-significant qubit once (results differ with every run)</span>
<span class="n">c_result</span><span class="p">,</span> <span class="n">q_result</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">measure</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-Measurement Projected State:&#39;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">q_result</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Single-Measurement Classical Outcome:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c_result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Statevector:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[|\textit{w}\rangle =\frac{\sqrt{3}}{3} |001\rangle+\frac{\sqrt{3} i}{3} |010\rangle- \frac{\sqrt{3}}{3} |100\rangle\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Probabilities of measuring 0 or 1 in q0:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle \left[\begin{matrix}\frac{2}{3} &amp; \frac{1}{3}\end{matrix}\right]\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Single-Measurement Projected State:
</pre></div>
</div>
<div class="output text_latex math notranslate nohighlight">
\[\frac{\sqrt{2} i}{2} |010\rangle- \frac{\sqrt{2}}{2} |100\rangle\]</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Single-Measurement Classical Outcome:

0
</pre></div>
</div>
</div>
</div>
<p>And, of course, when dealing with circuits, we can add a measurement block to just the qubits we are interested in measuring:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Add only one classical register to measure q0</span>

<span class="c1"># prepare |w⟩</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cry</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">)),</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cry</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)),</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="n">qc</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="c1"># measure only qubit 0</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Save statevector after performing measurement</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_statevector</span><span class="p">()</span> 
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/725188eb9fbc2b02f8ae76b4a63048bc02006f68752dbfce7bb475dc89072120.png" src="../../_images/725188eb9fbc2b02f8ae76b4a63048bc02006f68752dbfce7bb475dc89072120.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run simulation</span>
<span class="n">simulator</span> <span class="o">=</span> <span class="n">AerSimulator</span><span class="p">()</span>
<span class="n">qc_t</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">simulator</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_t</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="c1"># Extract projected statevector for one measurement</span>
<span class="n">w_meas</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
<span class="n">display</span><span class="p">(</span><span class="n">w_meas</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\frac{\sqrt{2} i}{2} |010\rangle- \frac{\sqrt{2}}{2} |100\rangle\]</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract samples from running circuit 1000 times</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_distribution</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/e0fdb2639d7ab5fe7c78666004d9738c42dc35beda4d8825d61e749087c65612.png" src="../../_images/e0fdb2639d7ab5fe7c78666004d9738c42dc35beda4d8825d61e749087c65612.png" />
</div>
</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./chapters/02_quantum_computing"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="02_03_single_qb_sys.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Single-Qubit Systems</p>
      </div>
    </a>
    <a class="right-next"
       href="02_05_quantum_blocks.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Quantum Building Blocks</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-states">1. Multi-Qubit States</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-gates">2. Multi-Qubit Gates</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#one-qubit-gates-on-multiple-qubits">2.1 One-Qubit Gates (on Multiple Qubits)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">2.2 Multi-Qubit Gates</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#controlled-gates">2.2.1 Controlled Gates</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#the-swap-gate">2.2.2 The SWAP Gate</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-copy-gate-no-cloning-theorem">2.3 The Copy Gate (No-Cloning Theorem)</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#universal-gate-sets">2.4 Universal Gate Sets</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multi-qubit-measurements">3. Multi-Qubit Measurements</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#full-state-measurement">3.1 Full State Measurement</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-state-measurement">3.2 Partial State Measurement</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Diego Emilio Serrano
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>